<?php

/**
 * Implements hook_menu().
 */
function rescued_menu() {
  $items = [];
  $items['admin/structure/xtuple'] = [
    'title' => "xTuple",
    'menu_name' => 'management',
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
    'weight' => -100,
  ];
  return $items;
}

/**
 * Implements hook_hook_info().
 */
function rescued_hook_info() {
  $hooks = [
    'rescued_entity_build_content_view' => [
      'group' => 'rescued',
    ],
  ];

  return $hooks;
}

/**
 * Implements hook_entity_info().
 *
 * We are programmatically building entities here.
 */
function rescued_entity_info() {
  if ($cache = cache_get('rescued_entity_info')) {
    $return = $cache->data;
  }
  else {
    $discovery = rescued_get_discovery_client_docs();
    $return = [];
    // Build up entity info array.
    if (isset($discovery)) {
      foreach ($discovery as $name => $properties) {
        foreach ($properties['schemas'] as $resource => $schemas) {
          // Add an entity for all JSON-Schema properties.
          $resource_key = rescued_json_schema_get_resource_key($schemas['properties']);
          if (empty($resource_key)) {
            watchdog("rescued", "!resource doesn't have a key, so it's a service; skipping entity declaration", [
              '!resource' => $resource,
            ]);
          }
          else {
            $resource_code = $name . '_' . strtolower($resource);
            $persistent_cache_type = \Xtuple\Rescued\Controller\EntityController::CACHE_PER_USER;
            if (in_array($resource_code, xdruple_cache_entity_system_wide())) {
              $persistent_cache_type = \Xtuple\Rescued\Controller\EntityController::CACHE_PER_SYSTEM;
            }
            $entity['persistent cache'] = $persistent_cache_type;
            $return[$resource_code] = [
              'label' => t($resource),
              'resource' => $resource,
              'discovery-client' => $name,
              'json-schema' => rescued_get_single_json_schema($resource, $properties['schemas']),
              'controller class' => '\Xtuple\Rescued\Controller\EntityController',
              'api-list-callback' => 'rescued_api_resource_list',
              // @todo: call rescued_api_resource_list statically in code
              'field cache' => FALSE,
              // TODO: For development only
              'fieldable' => TRUE,
              'entity keys' => [
                'id' => $resource_key,
                'label' => $resource_key,
              ],
              'label callback' => 'entity_class_label',
              'bundle keys' => [],
              'base table' => NULL,
              'bundles' => [
                $resource_code => [
                  'label' => t($resource),
                ],
              ],
              'view modes' => [
                'full' => [
                  'label' => t('Full content'),
                  'custom settings' => FALSE,
                ],
              ],
              // Entity API properties.
              'module' => 'rescued',
              'entity class' => '\Xtuple\Rescued\Controller\Entity',
              'permission labels' => [
                'singular' => $resource,
                'plural' => $resource,
              ],
              'access callback' => 'rescued_access',
            ];

            if ($properties['schemas'][$resource]['properties'][$resource_key]['type'] === 'string') {
              $return[$resource_code]['uuid'] = TRUE;
              $return[$resource_code]['entity keys']['uuid'] = $resource_key;
            }

            // Augment the JSON-Schema entities that are also a resource.
            // These are the main entities that have a UI.
            if (isset($properties['resources'][$resource])) {
              // Generic callback: one less callback to define.
              $return[$resource_code]['resource-methods'] = $properties['resources'][$resource]['methods'];
            }
            else {
              // The 'is_nested_only' resources are not exposed by the REST API and must be accessed by through their parent.
              $return[$resource_code]['is_nested_only'] = TRUE;
            }
          }
        }
      }
      cache_set('rescued_entity_info', $return);
    }
  }

  return $return;
}

/**
 * Check if the resources exist yet. This function can be called to ensure the
 * entities you need are loaded before preforming any action. It is useful to
 * prevent errors during install and cache refreshing.
 *
 * @param array $resources
 *   An array of resource names.
 *
 * @return boolean
 *   True if all resources in the array exist.
 */
function rescued_resources_exist($resources) {
  $client = rescued_api_get_client();
  foreach ($resources as $resource_name) {
    $entityName = 'xtuple_' . strtolower($resource_name);
    $entityInfo = entity_get_info($entityName);
    if (empty($entityInfo)) {
      return FALSE;
    }
    if ($client->resource($resource_name) === NULL) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Access callback for RESCUED entities.
 *
 * @param string   $op
 * @param          $entity
 * @param stdClass $account
 * @param string   $entity_type
 *
 * @return bool
 */
function rescued_access($op, $entity, $account = NULL, $entity_type = NULL) {
  /** @var \stdClass $user */
  global $user;
  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;

  // TODO: Add caching to this function.
  if (!isset($account)) {
    $account = $user;
  }

  $is_admin = user_access('administer rescued entities', $account);
  if (!$is_admin && $user->uid !== 0 && ($session->getRescued('expires', 0) < time())) {
    $account = rescued_reset_session($account);
  }

  $entityInfo = entity_get_info($entity_type);

  switch ($op) {
    case 'create':
      if (!$is_admin && isset($entityInfo) && (
          user_access('create personal rescued entities', $account)
          || user_access('create limited rescued entities', $account)
          || user_access('create contact rescued entities', $account)
          || user_access('create employee rescued entities', $account)
        )
      ) {
        // TODO: What should these users be allowed to create?
        return rescued_xtuple_entity_access_role_check($op, $account, $entity_type);
      }
      elseif ($is_admin || user_access('create any rescued entities', $account)) {
        return TRUE;
      }
      else {
        return FALSE;
      }
    case 'delete':
      if (!$is_admin && isset($entityInfo) && (
          user_access('delete personal rescued entities', $account)
          || user_access('delete limited rescued entities', $account)
          || user_access('delete contact rescued entities', $account)
          || user_access('delete employee rescued entities', $account)
        )
      ) {
        return rescued_xtuple_entity_access_role_check($op, $account, $entity_type);
      }
      elseif ($is_admin || user_access('delete any rescued entities', $account)) {
        return TRUE;
      }
      else {
        return FALSE;
      }
    case 'edit':
    case 'update':
      if (!$is_admin && isset($entityInfo) && (
          user_access('edit personal rescued entities', $account)
          || user_access('edit limited rescued entities', $account)
          || user_access('edit contact rescued entities', $account)
          || user_access('edit employee rescued entities', $account)
        )
      ) {
        return rescued_xtuple_entity_access_role_check($op, $account, $entity_type);
      }
      elseif ($is_admin || user_access('edit any rescued entities', $account)) {
        return TRUE;
      }
      else {
        return FALSE;
      }
    case 'view':
      if (!$is_admin && isset($entityInfo) && (
          user_access('view public rescued entities', $account)
          || user_access('view personal rescued entities', $account)
          || user_access('view limited rescued entities', $account)
          || user_access('view contact rescued entities', $account)
          || user_access('view employee rescued entities', $account)
        )
      ) {
        return rescued_xtuple_entity_access_role_check($op, $account, $entity_type);
      }
      elseif ($is_admin || user_access('view any rescued entities', $account)) {
        return TRUE;
      }
      else {
        return FALSE;
      }
  }
}

/**
 * Determine this user's xTuple Contact association and what role they belong to.
 *
 * @param $account
 *
 * @return
 */
function rescued_reset_session($account) {
  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;

  // Unset OAuth session values so they get rebuilt below.
  unset($_SESSION['access_token']);
  unset($_SESSION['oauth_user']);
  $session->removeRescued('user');

  // Check if the rescued resources exist yet. This function can be called before all entities are setup.
  //  Just return account if it's not ready.
  $resources = [
    'Account',
    'ContactRelation',
    'XdCustomer',
    'XdShipTo',
  ];
  if (!rescued_resources_exist($resources)) {
    return $account;
  }

  $app_name = rescued_application_name();
  $queryParams = [
    'query' => [
      'drupalUserUuid' => [
        'EQUALS' => $account->uuid,
      ],
      'xdruple_site' => [
        'EQUALS' => $app_name,
      ],
    ],
  ];

  // TODO: Get WSClient name.
  $user2contact = rescued_api_resource_list('XdUserContact', $queryParams);

  if ($user2contact && count($user2contact) === 1) {
    // TODO: This will break if this incident gets resolved: www.xtuple.org/xtincident/view/features/17846
    // We will have to handle multiple accounts on one contact.
    $session->set('rescued', $user2contact[0]);
    $session->setRescued('expires', time() + 3600); // One hour from now, this will be reloaded.

    // Remove 'account' from the $_SESSION, we'll set roles below from the account.
    $session->removeRescued('account');

    // XdUserContact doesn't have the account parameter because end users fill out the contact for at User Reg.
    // We need to get a Contact resource that have account and accountParent params.
    // TODO: Consider loading the full account resource to check for employee, owner roles.
    $user2account = rescued_api_resource_load('ContactRelation', $user2contact[0]['contact']['number'], 'number');

    if (!isset($user2account, $user2account['data']['account'])) {
      // This is a basic user2contact and not yet a customer.
      // TODO: Should get this key 'number' from discovery doc.

      // TODO: We need a role to support a basic public user that does not have an xTuple user yet.
      $session->setRescued('user_type', 'rescued_contact');
    }
    else {
      $session->setRescued('user', strtolower($user2account['data']['account']));

      // Get this CRM Account and figure out what type of user it is.
      $crmAccount = rescued_api_resource_load('Account', $user2account['data']['account'], 'number');

      // CRM Accounts with a parent Account are limited users unless they are a Customer, Rep or Employee.
      if ($user2account['data']['accountParent'] &&
        empty($crmAccount['data']['customer']) &&
        empty($crmAccount['data']['employee']) &&
        empty($crmAccount['data']['salesRep'])
      ) {

        $cust_number = $user2account['data']['accountParent'];
        $session->setRescued('user_type', 'rescued_limited');
      }
      elseif (isset($crmAccount['data']['employee'])) {
        // An Employee has more access. This could also be a Customer or Sales Rep.
        $cust_number = $user2account['data']['account'];
        $session->setRescued('user_type', 'rescued_employee');
      }
      else {
        $cust_number = $user2account['data']['account'];
        $session->setRescued('user_type', 'rescued_personal');
      }

      // There is a chance that a CRM Account is not a Customer, so we do a list query.
      // Save the customer data this user is associated with to the $_SESSION.
      $queryParams = [
        'query' => [
          'number' => [
            'EQUALS' => $cust_number,
          ],
        ],
      ];
      $customer = rescued_api_resource_list('XdCustomer', $queryParams);
      if (!empty($customer) && count($customer) === 1) {
        $id = $customer[0]['number'];
        $customer = $customer[0];

        // Set $_SESSION['rescued']['customer'] default.
        $session->setRescued('customer', $id);
        $session->setRescued('customer_terms', $customer['terms']);
        $session->setRescued('customer_credit', $customer['creditStatus']);

        // Figure out if the user can only access one ship to and set it to the $_SESSION['rescued']['ship_to'] default.
        $ship_tos = xdruple_fields_get_ship_to_list($id);
        if (!empty($ship_tos) && count($ship_tos) === 1) {
          $session->setRescued('ship_to', array_shift(array_keys($ship_tos)));
        }
        else {
          // Or set $_SESSION['rescued']['ship_to'] default to the Customer's default Ship To.
          $session->setRescued('ship_to', xdruple_fields_get_ship_to_default($id));
        }
        $session->setRescued('custom_ship_to', FALSE);

        // Set $_SESSION['rescued']['site'] default to the Customer's preferred site.
        if (!empty($customer['preferredSite'])) {
          $session->setRescued('site', $customer['preferredSite']);
        }
        else {
          $session->setRescued('site', variable_get('xdruple_commerce_default_warehouse', NULL));
        }

        xdruple_rescued_scheduled_date('tomorrow');
      }
    }
  }

  return $account;
}

/**
 * Check if the entity being accesses has a property that is related to this
 * user's role. e.g. If the user is a Sales Rep, is this entity related to one
 * of the rep's accounts.
 *
 * @param String $op
 *   The operation being performed. e.g. "view", "edit", etc.
 *
 * @param Object $account
 *   The current user object.
 * @param String $entity_type
 *   The entity type we're checking access for.
 *
 * @return boolean Has access or not.
 */
function rescued_xtuple_entity_access_role_check($op, $account, $entity_type) {
  // TODO: Move this out of RESCUED module and into an xTuple module.
  $entityInfo = entity_get_info($entity_type);

  // White list of resource types what are viewable by all.
  // TODO: Expose this through an admin setting.
  $white_list = [
    // TODO: Create white list.
    'State' => TRUE,
  ];

  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;

  if ($op === 'view' && isset($white_list[$entityInfo['resource']])) {
    return TRUE;
  }
  elseif ($op !== 'view' && isset($white_list[$entityInfo['resource']])) {
    // Only admins and employees should be able to create/update/delete
    // $white_list entities.
    return FALSE;
  }
  elseif ($session->getRescued('user')) {
    // For non-white_list entities, we check if the user's rescued role gives then access to this entity through it's relations.

    // Figure out what role we're dealing with.
    if (user_access('view personal rescued entities', $account)) {
      // TODO: Need a whitelist for 'rescued_personal'.
      return TRUE;
    }
    elseif (user_access('view limited rescued entities', $account)) {
      // TODO: Need a whitelist for 'rescued_limited'.
      return TRUE;
    }
    elseif (user_access('view contact rescued entities', $account)) {
      // TODO: Add support for basic contacts that will be accessing the API as a public user.
      // TODO: Need a whitelist for 'rescued_contact'.
      return FALSE;
    }
    elseif (user_access('view employee rescued entities', $account)) {
      // TODO: Need a whitelist for 'rescued_employee'.
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_entity_property_info().
 */
function rescued_entity_property_info() {
  $discovery = rescued_get_discovery_client_docs();

  $info = [];

  // Build up info properties array for each resource entity.
  if (isset($discovery)) {
    foreach ($discovery as $name => $resources) {
      foreach ($resources['schemas'] as $resource => $properties) {
        foreach ($properties['properties'] as $key => $value) {
          if (isset($value['type'])) {
            $format = isset($value['format']) ? $value['format'] : NULL;
            $type = rescued_json_schema_to_data_type($value['type'], $format);
          }
          else {
            $type = 'text';
          }
          $info[$name . '_' . strtolower($resource)]['properties'][$key] = [
            'description' => t(isset($value['comment']) ? $value['comment'] : ""),
            'label' => t($value['title']),
            'required' => isset($value['required']) ? $value['required'] : FALSE,
            'type' => $type,
          ];

          // Our dates come in as JavaScript dates. Need to define getter and setter callbacks that will convert them to timestamps.
          if ($type === 'date') {
            $info[$name . '_' . strtolower($resource)]['properties'][$key]['getter callback'] = 'entity_property_verbatim_date_get';
            // TODO: There is no set function for date.  Add a custom one.
            // @See: contrib/entity/includes/entity.property.inc, line 410
            // Currently this doesn't seem to be needed because our forms use 'Y-m-d'.
            // The getter is needed so views can use a date widget.
          }
        }
      }
    }
  }

  return $info;
}

/**
 * Implements hook_field_extra_fields().
 */
function rescued_field_extra_fields() {
  $discovery = rescued_get_discovery_client_docs();

  $extra = [];
  $handled_properties = [];

  // Build up entity fields array.
  if (isset($discovery)) {
    $created_fields = [];
    $erp_fields = [];

    // Get all of the default 'erp_xxx' fields so we can delete invalid ones below.
    $xd_ref_fields = field_read_fields(['type' => 'xdruple_entityreference']);

    // Loop over and find 'erp_xxx' fields.
    foreach ($xd_ref_fields as $field_key => $field) {
      if (substr($field_key, 0, 4) === 'erp_') {
        $erp_fields[] = $field_key;
      }
    }

    foreach ($discovery as $name => $resources) {
      $handled_properties[$name] = [];

      // Allow modules to register as a create_child_fields handler for a $resource[$property].
      drupal_alter('rescued_handle_create_child_fields', $handled_properties);

      foreach ($resources['schemas'] as $resource => $properties) {
        foreach ($properties['properties'] as $key => $value) {
          // Set weight based on type.
          if (isset($value['$ref']) && strpos($value['$ref'], '/') === FALSE) {
            // Handle toOne nested relations.

            $cardinality = 1;
            $weight = 20;
            $child = $value['$ref'];
            $new_field = rescued_create_child_fields($name, $resource, $key, $child, $value['title'], $cardinality, $weight, $handled_properties);
            if (!empty($new_field)) {
              $created_fields[] = $new_field;
            }
          }
          elseif ((isset($value['items']) && isset($value['items']['$ref']) &&
            strpos($value['items']['$ref'], '/') === FALSE)
          ) {
            // Handle toMany nested relations.

            $cardinality = FIELD_CARDINALITY_UNLIMITED;
            $weight = 10;
            $child = $value['items']['$ref'];
            $new_field = rescued_create_child_fields($name, $resource, $key, $child, $value['title'], $cardinality, $weight, $handled_properties);
            if (!empty($new_field)) {
              $created_fields[] = $new_field;
            }

            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['display'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['form'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
          }
          elseif (isset($value['items']) && isset($value['items']['$ref']) &&
            strpos($value['items']['$ref'], '/') !== FALSE
          ) {
            // Handle toMany key relations.

            $cardinality = FIELD_CARDINALITY_UNLIMITED;
            $weight = 30;
            $child = strtolower(array_shift(explode('/', $value['items']['$ref'], 2)));
            $new_field = rescued_create_child_fields($name, $resource, $key, $child, $value['title'], $cardinality, $weight, $handled_properties);
            if (!empty($new_field)) {
              $created_fields[] = $new_field;
            }

            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['display'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['form'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
          }
          else {
            $weight = -40;

            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['display'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
            $extra[$name . '_' . strtolower($resource)][$name . '_' . strtolower($resource)]['form'][$key] = [
              'description' => t(isset($value['comment']) ? $value['comment'] : ""),
              'label' => t($value['title']),
              'weight' => $weight,
            ];
          }
        }
      }
    }

    // Delete invalid erp_xxx fields.
    foreach ($erp_fields as $erp_field_name) {
      if (!in_array($erp_field_name, $created_fields)) {
        field_delete_field($erp_field_name);
      }
    }
    // Purge 'erp_xxx' fields.
    field_purge_batch(100);
  }

  return $extra;
}

/**
 * Creates fields for child relations on rescued entities.
 *
 * @param string  $name
 *  Name of rescued client.
 *
 * @param string  $resource
 *  Name of rescued client resource.
 *
 * @param string  $property
 *  Name of resource property.
 *
 * @param string  $child
 *  The child resource name.
 *
 * @param string  $title
 *  The title of the property.
 *
 * @param integer $cardinality
 *  The cardinality of the property.
 *
 * @param integer $weight
 *  Field weight for sort order.
 *
 * @param array   $handled_properties
 *  $resource and $properties registered to be handled by another module.
 *
 * @return null|string
 */
function rescued_create_child_fields($name, $resource, $property, $child, $title, $cardinality, $weight, $handled_properties) {
  $field_name = NULL;

  // Check $resource and $property to see if it's registered to be handled by another module.
  if (isset($handled_properties[$name], $handled_properties[$name][$resource]) &&
    in_array($property, $handled_properties[$name][$resource])
  ) {

    // Let other modules handle setting up this field.
    module_invoke_all('rescued_create_child_fields', $name, $resource, $property, $child, $title, $cardinality, $weight);
  }
  else {
    // Handle default field creation for non-registered $resource[$property].
    $field_name = xdruple_entityreference_create_default_child_fields($name, $resource, $property, $child, $title, $cardinality, $weight);
  }

  return $field_name;
}

/**
 * Implements hook_entity_query_alter().
 *
 * @param $query
 */
function rescued_entity_query_alter(&$query) {
  $conditions = $query->entityConditions;

  // Alter only RESCUED module entities.
  if (isset($conditions['entity_type']) &&
    (($entityInfo = entity_get_info($conditions['entity_type']['value'])) &&
      isset($entityInfo['module']) &&
      strpos($entityInfo['module'], 'rescued') !== FALSE)
  ) {
    $query->executeCallback = 'rescued_entity_field_query_builder';
  }
}

/**
 * Override EntityFieldQuery's execute() to make queries over the REST API.
 *
 * @param EntityFieldQuery $query
 *
 * @return array REST API Query Result.
 */
function rescued_entity_field_query_builder(EntityFieldQuery $query) {
  $propertyConditions = $query->propertyConditions;
  $order = $query->order;
  $entityType = $query->entityConditions['entity_type']['value'];
  $entityInfo = entity_get_info($entityType);

  $queryParams = [];
  if (isset($propertyConditions)) {
    foreach ($propertyConditions as $queryParam) {
      if (isset($queryParam['operator']) && $queryParam['operator'] === 'IN') {
        // TODO: Need to add support for array searches. Just grabbing one value for now.
        // This gets call when saving a node with a product reference field.
        // It sends an array of product_ids.
        $queryParam['value'] = array_pop($queryParam['value']);
      }
      if (count($queryParam['column']) > 1) {
        // TODO: Should we query on each column?
        $queryParams['q'] = $queryParam['value'];
      }
      else {
        if ($queryParam['column'] === 'q') {
          $queryParams['q'] = $queryParam['value'];
        }
        else {
          // Convert query types to xTuple format.
          $type = rescued_json_schema_get_property_type($entityInfo['json-schema'][$entityInfo['resource']], $queryParam['column']);

          if ($type === 'boolean') {
            $queryParam['value'] = empty($queryParam['value']) ? FALSE : TRUE;
          }

          $queryParams['query'][$queryParam['column']] = [
            isset($queryParam['operator']) ? rescued_get_query_operator($queryParam['operator']) : 'EQUALS' => $queryParam['value'],
          ];
        }
      }
    }
  }

  if (count($order) > 0) {
    $queryParams['orderby'] = [];

    foreach ($order as $orderby) {
      if (strtolower($orderby['direction']) === 'asc') {
        $queryParams['orderby'][$orderby['specifier']] = 'ASC';
      }
      elseif (strtolower($orderby['direction']) === 'desc') {
        $queryParams['orderby'][$orderby['specifier']] = 'DESC';
      }
    }

    if (count($queryParams['orderby']) === 0) {
      unset($queryParams['orderby']);
    }
  }

  if ($query->count) {
    // Call the REST API and get a count quicker than a full load request.
    $queryParams['count'] = TRUE;
    $entityInfo = entity_get_info($entityType);
    $api_callback = $entityInfo['api-list-callback']; // @todo: call rescued_api_resource_list statically
    $count = $api_callback($entityInfo['resource'], $queryParams);

    return isset($count[0]['count']) ? $count[0]['count'] : 0;
  }

  $pager_range = [];
  if (isset($query->range, $query->range['length'], $query->range['start'])) {
    $pager_range = [
      'maxResults' => $query->range['length'],
      'pageToken' => $query->range['start'] / $query->range['length']
    ];
  }

  $conditions = array_merge($queryParams, $pager_range);

  $entities = entity_load($entityType, FALSE, $conditions);

  $result = [
    $entityType => $entities,
  ];

  return $result;
}

/**
 * Implements hook_ctools_plugin_api().
 *
 * This hook is needed to let ctools know about exportables.
 * If you create field groups by using hook_field_group_info, you
 * will need to include the ctools api hook as well.
 *
 * @param string $module
 * @param string $api
 *
 * @return array
 */
function rescued_ctools_plugin_api($module, $api) {
  if ($module == 'field_group' && $api == 'field_group') {
    return ['version' => 1];
  }
}

/**
 * Implements hook_field_group_info().
 *
 * Put all generated entity properties that are a JSON-Schema '$ref'
 * inside a field group so there's some logic to the display.
 */
function rescued_field_group_info() {
  // Loop over discovery clients and add all $ref objects as field groups.
  $discovery = rescued_get_discovery_client_docs();

  $field_groups = [];

  if (isset($discovery)) {
    foreach ($discovery as $name => $properties) {
      foreach ($properties['resources'] as $resource => $methods) {
        $field_group_tab = new stdClass;
        $field_group_tab->api_version = 1;
        $field_group_tab->identifier = 'group_tabs|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default';
        $field_group_tab->group_name = 'group_tabs';
        $field_group_tab->entity_type = $name . '_' . strtolower($resource);
        $field_group_tab->bundle = $name . '_' . strtolower($resource);
        $field_group_tab->mode = 'default';
        $field_group_tab->parent_name = '';
        $field_group_tab->data = [
          'label' => 'tabs',
          'weight' => '90',
          'children' => [],
          'format_type' => 'htabs',
          'format_settings' => [
            'formatter' => '',
            'instance_settings' => [
              'classes' => 'group-tabs field-group-fieldset ',
            ],
          ],
        ];

        if (isset($properties['schemas'][$resource]['properties'])) {
          foreach ($properties['schemas'][$resource]['properties'] as $key => $value) {
            if (isset($value['items']) && isset($value['items']['$ref'])
              // TODO: This would remove toMany key relations from htabs
            ) {
              $field_group_tab->data['children'][] = 'group_' . $key;
              $field_group = new stdClass;
              $field_group->api_version = 1;
              $field_group->identifier = 'group_' . $key . '|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default';
              $field_group->group_name = 'group_' . $key;
              $field_group->entity_type = $name . '_' . strtolower($resource);
              $field_group->bundle = $name . '_' . strtolower($resource);
              $field_group->mode = 'default';
              $field_group->parent_name = 'group_tabs';
              $field_group->data = [
                'label' => $value['title'],
                'weight' => '80',
                'children' => [
                  0 => 'xd_' . strtolower($resource . $key),
                ],
                'format_type' => 'htab',
                'format_settings' => [
                  'formatter' => 'closed',
                  'instance_settings' => [
                    'description' => '', // TODO: Do we need this?
                    'classes' => 'group-' . $key . ' field-group-fieldset ',
                  ],
                ],
              ];

              $field_groups['group_' . $key . '|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default'] = $field_group;
            }

            if (isset($value['$ref']) && strpos($value['$ref'], '/') === FALSE) {
              $field_group = new stdClass;
              $field_group->api_version = 1;
              $field_group->identifier = 'group_' . $key . '|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default';
              $field_group->group_name = 'group_' . $key;
              $field_group->entity_type = $name . '_' . strtolower($resource);
              $field_group->bundle = $name . '_' . strtolower($resource);
              $field_group->mode = 'default';
              $field_group->parent_name = '';
              $field_group->data = [
                'label' => $value['title'],
                'weight' => '70',
                'children' => [
                  0 => 'xd_' . strtolower($resource . $key),
                ],
                'format_type' => 'fieldset',
                'format_settings' => [
                  'formatter' => 'collapsible',
                  'instance_settings' => [
                    'description' => '', // TODO: Do we need this?
                    'classes' => 'group-' . $key . ' field-group-fieldset ',
                    'required_fields' => 1,
                  ],
                ],
              ];

              $field_groups['group_' . $key . '|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default'] = $field_group;
            }
          }
        }

        $field_groups['group_tabs|' . $name . '_' . strtolower($resource) . '|' . $name . '_' . strtolower($resource) . '|' . 'default'] = $field_group_tab;
      }
    }
  }

  return $field_groups;
}

/**
 * Returns the human readable name of any or all xTuple entity types.
 *
 * @param $type
 *   Optional parameter specifying the type whose name to return.
 *
 * @return array|bool
 *   Either an array of all xTuple entity type names keyed by the machine name or a
 *   string containing the human readable name for the specified type. If a
 *   type is specified that does not exist, this function returns FALSE.
 */
function rescued_type_get_name($type = NULL) {
  // Loop over discovery clients and add all $ref objects as field groups.
  $discovery = rescued_get_discovery_client_docs();

  $rescued_types = [];

  if (isset($discovery)) {
    foreach ($discovery as $name => $properties) {
      foreach ($properties['resources'] as $resource => $methods) {
        $rescued_types[$name . '_' . strtolower($resource)] = t($resource);
      }
    }

    if (!empty($type)) {
      if (isset($rescued_types[$type])) {
        return $rescued_types[$type];
      }
      else {
        // Return FALSE if it does not exist.
        return FALSE;
      }
    }
    else {
      // Return all types.
      return $rescued_types;
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Build up the entity from a form submit, extracting the submitted values
 * and setting them on the corresponding entity properties.
 *
 * @param string  $entity_type
 * @param \Entity $entity
 * @param         $form
 * @param         $form_state
 */
function rescued_form_submit_build_entity($entity_type, $entity, $form, &$form_state) {
  $entityInfo = $entity->entityInfo();
  $resource = $entityInfo['resource'];
  $schema = $entityInfo['json-schema'][$resource]['properties'];
  $entity_values = drupal_array_get_nested_value($form_state['values'], $form['#parents']);
  $child_keys = [];

  // Build up the entity for non-Inline Entity Form properties and set null defaults.
  foreach ($schema as $key => $property) {
    if (!isset($schema[$key]['$ref']) && !isset($schema[$key]['items'])) {
      // Handle basic properties.
      if (empty($entity_values[$key])) {
        if (isset($property['isKey']) && $property['isKey'] &&
          (!isset($property['required']) || isset($entity->$key))
        ) {
          // This is a resource key field, but it's not required.
          // That means it will be auto assigned like a UUID. Set to null. Let API handle it.
          // Forms have the Key as read only, so it doesn't get set on $entity_values[$key].
          // Check if it's already set on the entity before we set it to null.
          $entity->$key = isset($entity->$key) ? $entity->$key : NULL;
        }
        elseif ($property['type'] === 'string' && (isset($property['format']) ? ($property['format'] !== 'date' && $property['format'] !== 'date-time') : TRUE)) {
          $entity->$key = "";
        }
        else {
          if ($property['type'] === 'boolean') {
            $entity->$key = FALSE;
          }
          else {
            $entity->$key = NULL;
          }
        }
      }
      elseif ($property['type'] === 'boolean') {
        if ($entity_values[$key]) {
          $entity->$key = TRUE;
        }
        else {
          $entity->$key = FALSE;
        }
      }
      elseif ($property['type'] === 'number') {
        // Cast to float.
        $entity->$key = (float) $entity_values[$key];
      }
      elseif ($property['type'] === 'integer') {
        // Cast to integer.
        $entity->$key = (int) $entity_values[$key];
      }
      else {
        $entity->$key = $entity_values[$key];
      }
    }
    elseif (isset($property['$ref']) && strpos($property['$ref'], '/') !== FALSE) {
      if (empty($entity_values[$key])) {
        if ($property['type'] === 'String') {
          $entity->$key = "";
        }
        else {
          $entity->$key = NULL;
        }
      }
      else {
        // Handle toOne key relations.
        if ($entity_values[$key]) {
          $entity->$key = $entity_values[$key];
        }
        else {
          $entity->$key = NULL;
        }
      }
    }
    elseif (isset($property['items']['$ref']) && strpos($property['items']['$ref'], '/') !== FALSE) {
      // Handle toMany key relations.
      $langcode = $form[$key]['#language'];
      if (empty($entity_values[$key][$langcode])) {
        $entity->$key = [];
      }
      else {
        $entity->$key = explode(', ', $entity_values[$key][$langcode]);
      }
    }
    else {
      // Build array of child key for Inline Entity Form handling below
      $child_keys[$key] = $key;
    }
  }

  foreach ($child_keys as $instance_name => $instance) {
    if (isset($form[$instance], $form[$instance]['#ief_id'])) {
      $field_name = $instance;
      $ief_id = $form[$field_name]['#ief_id'];

      // Skip if the field is not on the form or there is no IEF data for it.
      if (empty($form_state['inline_entity_form'][$ief_id])) {
        continue;
      }

      $values = $form_state['inline_entity_form'][$ief_id];

      if (isset($schema[$field_name]['items'])) {
        // Default toMany to an empty array.
        $entity->{$field_name} = [];
      }
      else {
        // Default toOne to null.
        $entity->{$field_name} = [];
      }
      foreach ($values['entities'] as $item) {
        $child_properties = entity_get_property_info($item['entity']->entityType());
        $child_fields = array_keys($child_properties['properties']);

        if (isset($schema[$field_name]['$ref'])) {
          // Handle toOne key relations
          foreach ($child_fields as $field_key) {
            $entity->{$field_name}[$field_key] = $item['entity']->$field_key;
          }
        }
        elseif (isset($schema[$field_name]['items'])) {
          // Handle toMany key relations
          $child_data = [];
          foreach ($child_fields as $field_key) {
            $child_data[$field_key] = $item['entity']->$field_key;
          }
          $entity->{$field_name}[] = $child_data;
        }
      }
    }
  }
}

/**
 * @return \Xtuple\REST\Client\Configuration
 * @throws \Exception
 */
function rescued_get_configuration() {
  global $rescued_config;
  if (empty($rescued_config)) {
    throw new Exception("RESCUED configuration is not set");
  }
  return $rescued_config;
}

/**
 * Shortcut to get application name
 */
function rescued_application_name() {
  $config = rescued_get_configuration();
  return $config->applicationName();
}

/**
 * @return array
 */
function rescued_resources_list() {
  $resources = module_invoke_all("rescued_resources");
  $resources = array_unique($resources);
  sort($resources);
  return $resources;
}

/**
 * @return \Xtuple\REST\Client\Client
 * @throws \Exception
 */
function rescued_get_xtuple_rest_service() {
  $configuration = rescued_get_configuration();
  variable_set('rescued_debug_mode', $configuration->debug());
  $resources = rescued_resources_list();
  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;
  $client = new \Xtuple\REST\Client\Client($configuration, $resources, $session);
  return $client;
}

/**
 * Implements hook_rescued_resources().
 */
function rescued_rescued_resources() {
  return [
    "Model",
    "XdUserContact",
    "Account",
    "ContactRelation",
    "XdCustomer",
  ];
}

/**
 * Get Discovery Docs for all 'discovery' WSClients.
 *
 * @return
 *   An multidimensional array of discovery docs keyed on the WSClient name.
 */
function rescued_get_discovery_client_docs() {
  $docs = &drupal_static(__FUNCTION__);

  if (!isset($docs)) {
    $client = rescued_get_xtuple_rest_service();
    $docs["xtuple"] = $client->discovery();
    try {
      $dir = "public://schemas";
      if (file_prepare_directory($dir, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
        foreach ($docs["xtuple"]["schemas"] as $resource => $schema) {
          $file = fopen("$dir/$resource.php", "w");
          $export = var_export($schema, TRUE);
          $export = str_replace("array (", "[", $export);
          $export = str_replace(")", "]", $export);
          $export = preg_replace("/=>\\ *\n\\ *\\[/", "=> [", $export);
          $export = str_replace("\$ref", "\\\$ref", $export);
          $export = str_replace("'", "\"", $export);
          $export = str_replace("true", "TRUE", $export);
          $export = str_replace("false", "FALSE", $export);
          $export = str_replace("null", "NULL", $export);
          fwrite($file, "<?php\n\n$export\n");
          fclose($file);
        }
      }
    } catch (\Exception $e) {
      watchdog_exception("rescued", $e);
    }
  }
  return $docs;
}

/**
 * Implements hook_flush_caches().
 *
 * Remove the folder at: /tmp/Google_Client and reset our entities loaded
 * variable and cache. This will be called when hook_menu() is called above
 * in rescued_module_implements_alter() and when all caches are flushed.
 */
function rescued_flush_caches() {
  // Clear the rescued_entity_info cache.
  cache_clear_all('rescued_entity_info', 'cache');

  // Delete Google IO cache folder from system's /tmp.
  if (variable_get('rescued_clear_google_cache', 1)) {
    global $apiConfig;
    if (file_exists($apiConfig['ioFileCache_directory'])) {
      file_unmanaged_delete_recursive($apiConfig['ioFileCache_directory']);
    }
  }
}

/**
 * Helper function to get all Discovery Service fields from the form.
 *
 * @param array $form
 *   The array containing the WSClient $form.
 *
 * @return array
 *   A data type array with $form_state keys that are part of the Discover Service settings.
 */
function rescued_get_discovery_form_fields($form) {
  $keys = [];
  foreach ($form as $key => $item) {
    // Skip form API setting keys.
    if (strpos($key, '#') !== FALSE) {
      continue;
    }
    // Recurse into any fieldsets and get the keys there.
    if (isset($item['#type']) && $item['#type'] === 'fieldset') {
      $keys = array_merge($keys, rescued_get_discovery_form_fields($item));
      continue;
    }
    $keys[] = $key;
  }

  return $keys;
}

/**
 * Convert metadata about data types provided by a Discovery Doc JSON-Schema
 * into a wsclient compatible data type array.
 *
 * @param array $types
 *   The array containing the struct strings.
 *
 * @return array
 *  A data type array with property information.
 */
function rescued_discovery_parse_types(array $types) {
  $wsclient_types = [];

  foreach ($types as $resource => $properties) {
    $wsclient_types[$resource] = ['label' => $resource];
    $wsclient_types[$resource]['property info'] = [];

    foreach ($properties['properties'] as $key => $value) {
      $wsclient_types[$resource]['property info'][$key] = [
        'type' => rescued_json_schema_to_data_type($value['type'], (isset($value['format']) ? $value['format'] : NULL)),
      ];
    }
  }

  return $wsclient_types;
}

/**
 * Convert metadata about operations provided by a Discovery Document into a
 * wsclient compatible operations array.
 *
 * @param array $operations
 *   The array containing the operation signature strings.
 *
 * @return array
 *   An operations array with parameter information.
 */
function rescued_discovery_parse_operations(array $operations) {
  $wsclient_operations = [];
  foreach ($operations as $resource => $properties) {
    foreach ($properties['methods'] as $method => $attr) {
      $wsclient_operations[$resource . '_' . $method] = [
        'label' => $resource . ' - ' . $method,
        // TODO: Not sure about this part. Need to do some tests with Rules module. Having Rules integration would we nice.
        'result' => [
          'type' => 'text',
          'label' => $resource . ' - ' . $method,
        ],
      ];

      if (isset($attr['parameters'])) {
        foreach ($attr['parameters'] as $key => $value) {
          $wsclient_operations[$resource . '_' . $method]['parameter'][$key] = [
            'type' => rescued_discovery_type_mapper($value['type']),
          ];
        }
      }
    }
  }

  return $wsclient_operations;
}

/**
 * Maps data type names from a Discovery Document to wsclient/rules internals.
 *
 * @param $type
 *
 * @return string
 */
function rescued_discovery_type_mapper($type) {
  $primitive_types = [
    'string',
    'int',
    'long',
    'float',
    'boolean',
    'double',
    'short',
    'decimal',
  ];

  if (in_array($type, $primitive_types)) {
    switch ($type) {
      case 'double':
      case 'float':
        return 'decimal';
      case 'int':
      case 'long':
      case 'short':
        return 'integer';
      case 'string':
        return 'text';
    }
  }

  // Check for list types.
  if (strpos($type, 'ArrayOf') === 0) {
    $type = substr($type, 7);
    $primitive = strtolower($type);
    if (in_array($primitive, $primitive_types)) {
      return 'list<' . $primitive . '>';
    }

    return 'list<' . $type . '>';
  }

  // Otherwise return the type as is.
  return $type;
}

/**
 * Initialize a WSClient and static cache the Client for all future requests.
 *
 * @return \Xtuple\Rescued\RescuedApiService
 * @throws \Exception
 */
function rescued_api_get_client() {
  $rescued = &drupal_static(__FUNCTION__);

  if (empty($rescued["xtuple"]["client"])) {
    $client = rescued_get_xtuple_rest_service();
    $rescued["xtuple"]["client"] = $client->service();
    $rescued["xtuple"]['prn'] = $client->config()->prn();
  }
  /** @var \Xtuple\Rescued\RescuedApiService $client */
  $client = $rescued["xtuple"]['client'];

  // Reset $oauth-prn because drupal_static's client may be stale.
  /** @var \Google_OAuth2 $auth */
  $auth = $client->client->getAuth();
  $oauth = $auth->assertionCredentials;

  if (isset($rescued["xtuple"]['prn'])) {
    $prn = $rescued["xtuple"]['prn'];
  }

  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;
  $oauth_user = NULL;

  // Set OAuth 2.0 JWT Delegated user.
  if ($role_user = $session->getRescued('user')) {
    if ((isset($_SESSION['oauth_user']) && $_SESSION['oauth_user'] !== $role_user) ||
      $oauth->prn !== $role_user
    ) {
      $oauth->prn = $role_user;
      $oauth_user = $role_user;
    }
  }
  elseif (isset($prn)) {
    if ((isset($_SESSION['oauth_user']) && $_SESSION['oauth_user'] !== $prn) ||
      $oauth->prn !== $prn
    ) {
      $oauth->prn = $prn;
      $oauth_user = $prn;
    }
  }

  // Reset AssertionCredentials so cached client has correct prn username and access token.
  if ($oauth_user !== NULL) {
    unset($_SESSION['access_token']);
    unset($_SESSION['oauth_user']);
    $auth->token = NULL;
    $_SESSION['oauth_user'] = $oauth_user;
    $client->client->setAssertionCredentials($oauth);
  }

  return $client;
}

/**
 * DELETE a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 *
 * @return
 */
function rescued_api_resource_delete($resource_name, $id, $resource_key) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource_name = $client->resource($resource_name)) {
    $result = $resource_name->delete($id, $resource_key);
  }
  return $result['data'];
}

/**
 * GET a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 *
 * @return array
 */
function rescued_api_resource_load($resource_name, $id, $resource_key) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource = $client->resource($resource_name)) {
    $result = $resource->get($id, $resource_key);
  }
  return $result;
}

/**
 * GET list of REST resources.
 *
 * @param string $resource_name
 * @param array  $opt_params
 * @param bool   $data_only
 *
 * @return array
 */
function rescued_api_resource_list($resource_name, $opt_params = [], $data_only = TRUE) {
  // If this is a large query and would result in a long URL, query over POST instead.
  // This will get around the "414 Request URI Too Large" error.
  // TODO: Is 500 characters too long?
  if (strlen(json_encode($opt_params)) > 500) {
    $result = rescued_api_resource_post_query($resource_name, $opt_params, FALSE);
  }
  else {
    $client = rescued_api_get_client();
    $result = [];
    if ($resource = $client->resource($resource_name)) {
      $result = $resource->resourceList($opt_params);
    }
  }

  if ($data_only) {
    return isset($result['data']) ? $result['data'] : [];
  }
  else {
    return isset($result) ? $result : [];
  }
}

/**
 * POST query for a list of REST resources.
 *
 * This function can be used to send a large query over a POST body instead of
 * constructing a really long URL that may fail with an error:
 * "414 Request URI Too Large".
 *
 * @param string  $resource         The API resource name. e.g. 'ClassCode'
 * @param array   $optParams        The structured query to perform.
 * @param boolean $data_only        Return just the data. Set to fails to get the
 *                                  full result that will include etags.
 *
 * @return array The query result response.
 */
function rescued_api_resource_post_query($resource, $optParams = [], $data_only = TRUE) {
  $client = rescued_api_get_client();

  // Build restQuery structure for the POST body.
  $postBody['attributes'] = [
    $resource,
    rescued_format_post_query_options($optParams),
  ];

  // Put all of this into the postBody where the Google lib expects it.
  $params = ['postBody' => $postBody];

  // Get the query results.
  $result = $client->Model->restQuery($params);

  if ($data_only) {
    return isset($result['data']) ? $result['data'] : [];
  }
  else {
    return isset($result) ? $result : [];
  }
}


/**
 * PATCH a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 * @param $postBody
 * @param $optParams
 *
 * @return array|\Xtuple\Rescued\RescuedService
 */
function rescued_api_resource_patch($resource_name, $id, $resource_key, $postBody, $optParams) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource = $client->resource($resource_name)) {
    $result = $resource->patch($id, $resource_key, $postBody, $optParams);
  }
  return $result;
}

/**
 * POST a REST resource.
 *
 * @param $resource_name
 * @param $postBody
 * @param $optParams
 *
 * @return array|\Xtuple\Rescued\RescuedService
 */
function rescued_api_resource_insert($resource_name, $postBody, $optParams) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource_name = $client->resource($resource_name)) {
    $result = $resource_name->insert($postBody, $optParams);
  }
  return $result;
}

/**
 * Helper function to format a GET style query options for POST query requests.
 *
 * @param array $optParams The structured query to perform.
 *
 * @return array The formatted query $options.
 */
function rescued_format_post_query_options($optParams = []) {

  // Build restQuery structure for the POST body.
  $options = [];

  // Format the query.
  if (isset($optParams['query'])) {
    foreach ($optParams['query'] as $key => $value) {
      $options['query'][] = [$key => $value];
    }
    unset($optParams['query']);
  }

  // Format the orderby.
  if (isset($optParams['orderby'])) {
    foreach ($optParams['orderby'] as $key => $value) {
      $options['orderby'][] = [$key => $value];
    }
    unset($optParams['orderby']);
  }

  // Add any other query info. e.g. rowlimit, pagetoken, maxresults or count.
  foreach ($optParams as $key => $value) {
    $options[$key] = $value;
  }

  return $options;
}

/**
 * Build a JSON-Schema array for a single entity.
 *
 * @param string $resource
 * @param array  $json_schema
 * @param string $discovery_client The client name.
 *
 * @return array JSON-Schema
 */
function rescued_get_single_json_schema($resource, $json_schema = NULL, $discovery_client = NULL) {
  // Find the resource in the JSON-Schema.
  $schema = [];

  // Load the schema from the discovery doc when not passed in.
  if (is_null($json_schema) && !is_null($discovery_client)) {
    $docs = rescued_get_discovery_client_docs();
    $json_schema = $docs[$discovery_client]['schemas'];
  }

  // Add the resource's properties to the schema.
  $schema[$resource] = $json_schema[$resource];

  return $schema;
}

/**
 * Build a JSON-Schema array for an entity including all $ref's recursively.
 *
 * @param string $resource
 * @param array  $json_schema
 *
 * @return array JSON-Schema
 */
function rescued_get_recursive_json_schema($resource, $json_schema) {
  // Find the resource in the JSON-Schema.
  $schema = [];

  // Add the resource's properties to the schema.
  $schema[$resource] = $json_schema[$resource];

  // If a property is a $ref, recurse into it and add it's properties as well.
  foreach ($schema[$resource]['properties'] as $property => $values) {
    if (isset($values['$ref']) && strpos($property['$ref'], '/') === FALSE) {
      // Handle toOne relations.
      $schema = $schema + rescued_get_recursive_json_schema($values['$ref'], $json_schema);
    }
    elseif (isset($values['$ref']) && strpos($property['$ref'], '/') !== FALSE) {
      // Handle toOne key relations.
      $ref_parent = explode("/", $values['$ref']);
      $schema = $schema + rescued_get_recursive_json_schema($ref_parent[0], $json_schema);
    }
    elseif (isset($properties['items']) && isset($properties['items']['$ref']) &&
      strpos($properties['items']['$ref'], '/') === FALSE
    ) {
      // Handle toMany isNested relations.
      $schema = $schema + rescued_get_recursive_json_schema($values['items']['$ref'], $json_schema);
    }
    elseif (isset($properties['items']) && isset($properties['items']['$ref']) &&
      strpos($properties['items']['$ref'], '/') !== FALSE
    ) {
      // Handle toMany key relations.
      $ref_parent = explode("/", $values['items']['$ref']);
      $schema = $schema + rescued_get_recursive_json_schema($ref_parent[0], $json_schema);
    }
  }

  return $schema;
}

/**
 * Map JSON-Schema data types to Drupal form field types.
 *
 * @param string $type JSON-Schema data type to map.
 * @param string $format
 *
 * @return string Drupal form field type.
 */
function rescued_json_schema_to_form_type($type, $format = NULL) {
  switch (strtolower($type)) {
    case 'object':
      return 'textfield';
    case 'array':
      return 'textfield';
    case 'boolean':
      return 'checkbox';
    case 'integer':
      return 'textfield';
    case 'number':
      return 'textfield';
    case 'string':
      if (isset($format) && $format === 'date') {
        return 'date_popup';
      }
      else {
        return 'textfield';
      }
    default:
      return 'textfield';
  }
}

/**
 * Map JSON-Schema data types to Drupal entity data types.
 *
 * @param string $type JSON-Schema data type to map.
 * @param string $format
 *
 * @return string Drupal data type.
 */
function rescued_json_schema_to_data_type($type, $format = NULL) {
  switch (strtolower($type)) {
    case 'object':
      return 'entities';
    case 'array':
      return 'list';
    case 'boolean':
      return 'boolean';
    case 'integer':
      return 'integer';
    case 'number':
      return 'decimal';
    case 'string':
      if (isset($format) && $format === 'date') {
        return 'date';
      }
      else {
        return 'text';
      }
  }
  return $type;
}

/**
 * Convert Drupal's query operator string to xTuple's.
 *
 * @param string
 *     Possible values:
 *     - '=', '<>', '>', '>=', '<', '<=', 'STARTS_WITH', 'CONTAINS': These
 *     operators expect $value to be a literal of the same type as the
 *     column.
 *     - 'IN', 'NOT IN': These operators expect $value to be an array of
 *     literals of the same type as the column.
 *     - 'BETWEEN': This operator expects $value to be an array of two literals
 *     of the same type as the column.
 *
 * @return string
 *   The converted operator string.
 */
function rescued_get_query_operator($operator) {
  switch ($operator) {
    case '=':
      return 'EQUALS';
    case '<>':
      return 'NOT_EQUALS';
    case '<':
      return 'LESS_THAN';
    case '<=':
      return 'AT_MOST';
    case '>':
      return 'GREATER_THAN';
    case '>=':
      return 'AT_LEAST';
    case 'CONTAINS':
      return 'MATCHES';
    case 'STARTS_WITH':
      return 'BEGINS_WITH';
    case 'IN':
      return 'EQUALS'; // TODO: support return "ANY"
    case 'NOT IN':
      return 'EQUALS'; // TODO: support return "NOT ANY"
    case 'BETWEEN':
      return 'EQUALS'; // TODO: support return "BETWEEN"
    default:
      return $operator;
  }
}

/**
 * Get the primary/natural key for a JSON-Schema resource.
 *
 * @param array $properties JSON-Schema properties for a single resource.
 *
 * @return string Key name.
 */
function rescued_json_schema_get_resource_key($properties) {
  foreach ($properties as $key => $values) {
    if (isset($values['isKey']) && $values['isKey']) {
      return $key;
    }
  }
  return NULL;
}

/**
 * Get the property data type from the resource's JSON-Schema.
 *
 * @param array  $schema   The JSON-Schema for a single resource.
 * @param string $property The property name to get the type for.
 *
 * @return string Key name.
 */
function rescued_json_schema_get_property_type($schema, $property) {
  if (isset($schema['properties'][$property]['type'])) {
    return $schema['properties'][$property]['type'];
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_features_exclude()
 */
function rescued_features_exclude() {
  return [
    'variable' => [
      'rescued_debug_mode',
    ],
  ];
}
