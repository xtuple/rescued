<?php

/**
 * Check if the resources exist yet. This function can be called to ensure the
 * entities you need are loaded before preforming any action. It is useful to
 * prevent errors during install and cache refreshing.
 *
 * @param array $resources
 *   An array of resource names.
 *
 * @return boolean
 *   True if all resources in the array exist.
 */
function rescued_resources_exist($resources) {
  $client = rescued_api_get_client();
  foreach ($resources as $resource_name) {
    if ($client->resource($resource_name) === NULL) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implements hook_entity_property_info().
 */
function rescued_entity_property_info() {
  $discovery = rescued_get_discovery_client_docs();

  $info = [];

  // Build up info properties array for each resource entity.
  if (isset($discovery)) {
    foreach ($discovery as $name => $resources) {
      foreach ($resources['schemas'] as $resource => $properties) {
        foreach ($properties['properties'] as $key => $value) {
          if (isset($value['type'])) {
            $format = isset($value['format']) ? $value['format'] : NULL;
            $type = rescued_json_schema_to_data_type($value['type'], $format);
          }
          else {
            $type = 'text';
          }
          $info[$name . '_' . strtolower($resource)]['properties'][$key] = [
            'description' => t(isset($value['comment']) ? $value['comment'] : ""),
            'label' => t($value['title']),
            'required' => isset($value['required']) ? $value['required'] : FALSE,
            'type' => $type,
          ];

          // Our dates come in as JavaScript dates. Need to define getter and setter callbacks that will convert them to timestamps.
          if ($type === 'date') {
            $info[$name . '_' . strtolower($resource)]['properties'][$key]['getter callback'] = 'entity_property_verbatim_date_get';
            // TODO: There is no set function for date.  Add a custom one.
            // @See: contrib/entity/includes/entity.property.inc, line 410
            // Currently this doesn't seem to be needed because our forms use 'Y-m-d'.
            // The getter is needed so views can use a date widget.
          }
        }
      }
    }
  }

  return $info;
}

/**
 * @return \Xtuple\REST\Client\Configuration
 * @throws \Exception
 */
function rescued_get_configuration() {
  global $rescued_config;
  if (empty($rescued_config)) {
    throw new Exception("RESCUED configuration is not set");
  }
  return $rescued_config;
}

/**
 * Shortcut to get application name
 */
function rescued_application_name() {
  $config = rescued_get_configuration();
  return $config->applicationName();
}

/**
 * @return array
 */
function rescued_resources_list() {
  $resources = module_invoke_all("rescued_resources");
  $resources = array_unique($resources);
  sort($resources);
  return $resources;
}

/**
 * @return \Xtuple\REST\Client\Client
 * @throws \Exception
 */
function rescued_get_xtuple_rest_service() {
  $configuration = rescued_get_configuration();
  variable_set('rescued_debug_mode', $configuration->debug());
  $resources = rescued_resources_list();
  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;
  $client = new \Xtuple\REST\Client\Client($configuration, $resources, $session);
  return $client;
}

/**
 * Implements hook_rescued_resources().
 */
function rescued_rescued_resources() {
  return [
    "Model",
    "Account",
    "ContactRelation",
    "XdCustomer",
  ];
}

/**
 * Get Discovery Docs
 *
 * @return
 *   An multidimensional array of discovery docs
 */
function rescued_get_discovery_client_docs() {
  $docs = &drupal_static(__FUNCTION__);

  if (!isset($docs)) {
    $client = rescued_get_xtuple_rest_service();
    $docs["xtuple"] = $client->discovery();
    try {
      $dir = "public://schemas";
      if (file_prepare_directory($dir, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
        foreach ($docs["xtuple"]["schemas"] as $resource => $schema) {
          $file = fopen("$dir/$resource.php", "w");
          $export = var_export($schema, TRUE);
          $export = str_replace("array (", "[", $export);
          $export = str_replace(")", "]", $export);
          $export = preg_replace("/=>\\ *\n\\ *\\[/", "=> [", $export);
          $export = str_replace("\$ref", "\\\$ref", $export);
          $export = str_replace("'", "\"", $export);
          $export = str_replace("true", "TRUE", $export);
          $export = str_replace("false", "FALSE", $export);
          $export = str_replace("null", "NULL", $export);
          fwrite($file, "<?php\n\n$export\n");
          fclose($file);
        }
      }
    } catch (\Exception $e) {
      watchdog_exception("rescued", $e);
    }
  }
  return $docs;
}

/**
 * Implements hook_flush_caches().
 *
 * Remove the folder at: /tmp/Google_Client and reset our entities loaded
 * variable and cache. This will be called when hook_menu() is called above
 * in rescued_module_implements_alter() and when all caches are flushed.
 */
function rescued_flush_caches() {
  // Clear the rescued_entity_info cache.
  cache_clear_all('rescued_entity_info', 'cache');

  // Delete Google IO cache folder from system's /tmp.
  if (variable_get('rescued_clear_google_cache', 1)) {
    global $apiConfig;
    if (file_exists($apiConfig['ioFileCache_directory'])) {
      file_unmanaged_delete_recursive($apiConfig['ioFileCache_directory']);
    }
  }
}

/**
 * Initialize a Rescued Client
 *
 * @return \Xtuple\Rescued\RescuedApiService
 * @throws \Exception
 */
function rescued_api_get_client() {
  $rescued = &drupal_static(__FUNCTION__);

  if (empty($rescued["xtuple"]["client"])) {
    $client = rescued_get_xtuple_rest_service();
    $rescued["xtuple"]["client"] = $client->service();
    $rescued["xtuple"]['prn'] = $client->config()->prn();
  }
  /** @var \Xtuple\Rescued\RescuedApiService $client */
  $client = $rescued["xtuple"]['client'];

  // Reset $oauth-prn because drupal_static's client may be stale.
  /** @var \Google_OAuth2 $auth */
  $auth = $client->client->getAuth();
  $oauth = $auth->assertionCredentials;

  if (isset($rescued["xtuple"]['prn'])) {
    $prn = $rescued["xtuple"]['prn'];
  }

  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  global $session;
  $oauth_user = NULL;

  // Set OAuth 2.0 JWT Delegated user.
  if ($role_user = $session->getRescued('user')) {
    if ((isset($_SESSION['oauth_user']) && $_SESSION['oauth_user'] !== $role_user) ||
      $oauth->prn !== $role_user
    ) {
      $oauth->prn = $role_user;
      $oauth_user = $role_user;
    }
  }
  elseif (isset($prn)) {
    if ((isset($_SESSION['oauth_user']) && $_SESSION['oauth_user'] !== $prn) ||
      $oauth->prn !== $prn
    ) {
      $oauth->prn = $prn;
      $oauth_user = $prn;
    }
  }

  // Reset AssertionCredentials so cached client has correct prn username and access token.
  if ($oauth_user !== NULL) {
    unset($_SESSION['access_token']);
    unset($_SESSION['oauth_user']);
    $auth->token = NULL;
    $_SESSION['oauth_user'] = $oauth_user;
    $client->client->setAssertionCredentials($oauth);
  }

  return $client;
}

/**
 * DELETE a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 *
 * @return
 */
function rescued_api_resource_delete($resource_name, $id, $resource_key) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource_name = $client->resource($resource_name)) {
    $result = $resource_name->delete($id, $resource_key);
  }
  return $result['data'];
}

/**
 * GET a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 *
 * @return array
 */
function rescued_api_resource_load($resource_name, $id, $resource_key) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource = $client->resource($resource_name)) {
    $result = $resource->get($id, $resource_key);
  }
  return $result;
}

/**
 * GET list of REST resources.
 *
 * @param string $resource_name
 * @param array  $opt_params
 * @param bool   $data_only
 *
 * @return array
 */
function rescued_api_resource_list($resource_name, $opt_params = [], $data_only = TRUE) {
  // If this is a large query and would result in a long URL, query over POST instead.
  // This will get around the "414 Request URI Too Large" error.
  // TODO: Is 500 characters too long?
  if (strlen(json_encode($opt_params)) > 500) {
    $result = rescued_api_resource_post_query($resource_name, $opt_params, FALSE);
  }
  else {
    $client = rescued_api_get_client();
    $result = [];
    if ($resource = $client->resource($resource_name)) {
      $result = $resource->resourceList($opt_params);
    }
  }

  if ($data_only) {
    return isset($result['data']) ? $result['data'] : [];
  }
  else {
    return isset($result) ? $result : [];
  }
}

/**
 * POST query for a list of REST resources.
 *
 * This function can be used to send a large query over a POST body instead of
 * constructing a really long URL that may fail with an error:
 * "414 Request URI Too Large".
 *
 * @param string  $resource         The API resource name. e.g. 'ClassCode'
 * @param array   $optParams        The structured query to perform.
 * @param boolean $data_only        Return just the data. Set to fails to get the
 *                                  full result that will include etags.
 *
 * @return array The query result response.
 */
function rescued_api_resource_post_query($resource, $optParams = [], $data_only = TRUE) {
  $client = rescued_api_get_client();

  // Build restQuery structure for the POST body.
  $postBody['attributes'] = [
    $resource,
    rescued_format_post_query_options($optParams),
  ];

  // Put all of this into the postBody where the Google lib expects it.
  $params = ['postBody' => $postBody];

  // Get the query results.
  $result = $client->Model->restQuery($params);

  if ($data_only) {
    return isset($result['data']) ? $result['data'] : [];
  }
  else {
    return isset($result) ? $result : [];
  }
}


/**
 * PATCH a REST resource.
 *
 * @param $resource_name
 * @param $id
 * @param $resource_key
 * @param $postBody
 * @param $optParams
 *
 * @return array|\Xtuple\Rescued\RescuedService
 */
function rescued_api_resource_patch($resource_name, $id, $resource_key, $postBody, $optParams) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource = $client->resource($resource_name)) {
    $result = $resource->patch($id, $resource_key, $postBody, $optParams);
  }
  return $result;
}

/**
 * POST a REST resource.
 *
 * @param $resource_name
 * @param $postBody
 * @param $optParams
 *
 * @return array|\Xtuple\Rescued\RescuedService
 */
function rescued_api_resource_insert($resource_name, $postBody, $optParams) {
  $result = [];
  $client = rescued_api_get_client();
  if ($resource_name = $client->resource($resource_name)) {
    $result = $resource_name->insert($postBody, $optParams);
  }
  return $result;
}

/**
 * Helper function to format a GET style query options for POST query requests.
 *
 * @param array $optParams The structured query to perform.
 *
 * @return array The formatted query $options.
 */
function rescued_format_post_query_options($optParams = []) {

  // Build restQuery structure for the POST body.
  $options = [];

  // Format the query.
  if (isset($optParams['query'])) {
    foreach ($optParams['query'] as $key => $value) {
      $options['query'][] = [$key => $value];
    }
    unset($optParams['query']);
  }

  // Format the orderby.
  if (isset($optParams['orderby'])) {
    foreach ($optParams['orderby'] as $key => $value) {
      $options['orderby'][] = [$key => $value];
    }
    unset($optParams['orderby']);
  }

  // Add any other query info. e.g. rowlimit, pagetoken, maxresults or count.
  foreach ($optParams as $key => $value) {
    $options[$key] = $value;
  }

  return $options;
}

/**
 * Build a JSON-Schema array for a single entity.
 *
 * @param string $resource
 * @param array  $json_schema
 * @param string $discovery_client The client name.
 *
 * @return array JSON-Schema
 */
function rescued_get_single_json_schema($resource, $json_schema = NULL, $discovery_client = NULL) {
  // Find the resource in the JSON-Schema.
  $schema = [];

  // Load the schema from the discovery doc when not passed in.
  if (is_null($json_schema) && !is_null($discovery_client)) {
    $docs = rescued_get_discovery_client_docs();
    $json_schema = $docs[$discovery_client]['schemas'];
  }

  // Add the resource's properties to the schema.
  $schema[$resource] = $json_schema[$resource];

  return $schema;
}

/**
 * Build a JSON-Schema array for an entity including all $ref's recursively.
 *
 * @param string $resource
 * @param array  $json_schema
 *
 * @return array JSON-Schema
 */
function rescued_get_recursive_json_schema($resource, $json_schema) {
  // Find the resource in the JSON-Schema.
  $schema = [];

  // Add the resource's properties to the schema.
  $schema[$resource] = $json_schema[$resource];

  // If a property is a $ref, recurse into it and add it's properties as well.
  foreach ($schema[$resource]['properties'] as $property => $values) {
    if (isset($values['$ref']) && strpos($property['$ref'], '/') === FALSE) {
      // Handle toOne relations.
      $schema = $schema + rescued_get_recursive_json_schema($values['$ref'], $json_schema);
    }
    elseif (isset($values['$ref']) && strpos($property['$ref'], '/') !== FALSE) {
      // Handle toOne key relations.
      $ref_parent = explode("/", $values['$ref']);
      $schema = $schema + rescued_get_recursive_json_schema($ref_parent[0], $json_schema);
    }
    elseif (isset($properties['items']) && isset($properties['items']['$ref']) &&
      strpos($properties['items']['$ref'], '/') === FALSE
    ) {
      // Handle toMany isNested relations.
      $schema = $schema + rescued_get_recursive_json_schema($values['items']['$ref'], $json_schema);
    }
    elseif (isset($properties['items']) && isset($properties['items']['$ref']) &&
      strpos($properties['items']['$ref'], '/') !== FALSE
    ) {
      // Handle toMany key relations.
      $ref_parent = explode("/", $values['items']['$ref']);
      $schema = $schema + rescued_get_recursive_json_schema($ref_parent[0], $json_schema);
    }
  }

  return $schema;
}

/**
 * Map JSON-Schema data types to Drupal form field types.
 *
 * @param string $type JSON-Schema data type to map.
 * @param string $format
 *
 * @return string Drupal form field type.
 */
function rescued_json_schema_to_form_type($type, $format = NULL) {
  switch (strtolower($type)) {
    case 'object':
      return 'textfield';
    case 'array':
      return 'textfield';
    case 'boolean':
      return 'checkbox';
    case 'integer':
      return 'textfield';
    case 'number':
      return 'textfield';
    case 'string':
      if (isset($format) && $format === 'date') {
        return 'date_popup';
      }
      else {
        return 'textfield';
      }
    default:
      return 'textfield';
  }
}

/**
 * Map JSON-Schema data types to Drupal entity data types.
 *
 * @param string $type JSON-Schema data type to map.
 * @param string $format
 *
 * @return string Drupal data type.
 */
function rescued_json_schema_to_data_type($type, $format = NULL) {
  switch (strtolower($type)) {
    case 'object':
      return 'entities';
    case 'array':
      return 'list';
    case 'boolean':
      return 'boolean';
    case 'integer':
      return 'integer';
    case 'number':
      return 'decimal';
    case 'string':
      if (isset($format) && $format === 'date') {
        return 'date';
      }
      else {
        return 'text';
      }
  }
  return $type;
}

/**
 * Convert Drupal's query operator string to xTuple's.
 *
 * @param string
 *     Possible values:
 *     - '=', '<>', '>', '>=', '<', '<=', 'STARTS_WITH', 'CONTAINS': These
 *     operators expect $value to be a literal of the same type as the
 *     column.
 *     - 'IN', 'NOT IN': These operators expect $value to be an array of
 *     literals of the same type as the column.
 *     - 'BETWEEN': This operator expects $value to be an array of two literals
 *     of the same type as the column.
 *
 * @return string
 *   The converted operator string.
 */
function rescued_get_query_operator($operator) {
  switch ($operator) {
    case '=':
      return 'EQUALS';
    case '<>':
      return 'NOT_EQUALS';
    case '<':
      return 'LESS_THAN';
    case '<=':
      return 'AT_MOST';
    case '>':
      return 'GREATER_THAN';
    case '>=':
      return 'AT_LEAST';
    case 'CONTAINS':
      return 'MATCHES';
    case 'STARTS_WITH':
      return 'BEGINS_WITH';
    case 'IN':
      return 'EQUALS'; // TODO: support return "ANY"
    case 'NOT IN':
      return 'EQUALS'; // TODO: support return "NOT ANY"
    case 'BETWEEN':
      return 'EQUALS'; // TODO: support return "BETWEEN"
    default:
      return $operator;
  }
}

/**
 * Get the primary/natural key for a JSON-Schema resource.
 *
 * @param array $properties JSON-Schema properties for a single resource.
 *
 * @return string Key name.
 */
function rescued_json_schema_get_resource_key($properties) {
  foreach ($properties as $key => $values) {
    if (isset($values['isKey']) && $values['isKey']) {
      return $key;
    }
  }
  return NULL;
}

/**
 * Get the property data type from the resource's JSON-Schema.
 *
 * @param array  $schema   The JSON-Schema for a single resource.
 * @param string $property The property name to get the type for.
 *
 * @return string Key name.
 */
function rescued_json_schema_get_property_type($schema, $property) {
  if (isset($schema['properties'][$property]['type'])) {
    return $schema['properties'][$property]['type'];
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_features_exclude()
 */
function rescued_features_exclude() {
  return [
    'variable' => [
      'rescued_debug_mode',
    ],
  ];
}
